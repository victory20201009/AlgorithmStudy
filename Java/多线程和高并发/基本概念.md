<center><font color="#FFA500" size="6">基本概念</font></center>

[TOC]

# 1. 程序、进程和线程

- 程序是一个静态的概念，可以理解为存放在磁盘上的一堆文件，存储了处理器执行的代码或处理的数据。

- 进程是一个动态的概念，当一个程序从磁盘被加载进内存，被操作系统调度执行的时候，就是一个进程（可以理解为一个操作系统的概念）；当然一个程序可以被多次加载进内存，生成多个进程。

- CPU在执行指令时，是按照指令顺序，是从上往下，顺序执行的，这样执行下来就是一个执行路径，线程就是在一个进程内部的特定执行路径，一个进程里可以有好多个执行路径，这几个执行路径在逻辑上互不干扰：例如扫雷游戏进程，它至少有一个计时线程用于计算用户的游戏时间，和用户操作的UI线程用于响应用户的界面操作；一个java进程，至少有一个main线程用于执行用户操作，和一个垃圾回收线程用于回收内存等。在单核心处理器上，这些线程的执行，是在操作系统的调度下，交替执行的。

多线程举例：

```java
package com.victory.thread.test;

import java.util.concurrent.TimeUnit;

public class ThreadTest{
    private static class MyThread extends Thread{
        @Override
        public void run(){
            for(int i=0;i<10;++i){
                try{
                    TimeUnit.MICROSECONDS.sleep(1);
                }catch(InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println("MyThread");
            }
        }
    }
    public static void main(String[] args){
        new MyThread().start();
        for(int i=0;i<10;++i){
            try{
                  TimeUnit.MICROSECONDS.sleep(1);
            }catch(InterruptedException e){
                    e.printStackTrace();
            }
            System.out.println("main");
        }
    } 
}
```

# 2. Java实现多线程的方式

1. 继承Thread类，重新run方法；
2. 实现Runnable接口，重新run
3. 实现Callable接口，重写call方法；
4. 使用线程池

```java
package com.victory.thread.test;

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadCreateTest{
    
    //继承Thread类
    static class MyThread extends Thread{
        @Override
        public void run(){
            System.out.println("MyThread");
        }
    }
    
    //实现Runnable接口
    static class MyRunnable implements Runnable{
        @Override
        public void run(){
            System.out.println("MyRunnable");
        }
    }
    
    //实现Callable接口
    static class MyCall implements Callable<String>{
        @Override
        public String call(){
            System.out.println("MyCall");
            return "SUCCESS";
        }
    }
    
    public static void main(String[] args){
        new MyThread().start();
        new Thread(new MyRunnable()).start();
        //实现Runnable也可以采用匿名内部类的方式实现，这里展示lambda形式
        new Thread(()->{
            System.out.println("lambda Runnable");
        }).start();
        new Thread(new FutureTask<String>(new MyCall())).start();
        
        ExecutorService eService = Executors.newCachedThreadPool();
        //实际上线程池这里传入的参数也是一个Runnable，这里采用lambda方式
        eService.execute(()->{
            System.out.println("Thread Pool");
        });
        eService.shutdown();
        
       //如果同时传入Runnable和重写run方法，则只会走run方法，查看Thread源码即可
        new Thread(()->{
            System.out.println("aaaa");
        }){
           @Override
            public void run(){
               System.out.println("sssss");
           }
        }.start();
    }
}
```

# 3. 线程池的简单介绍

## 3.1. Executor，Executors，ExecutorService，Future，Callable之间的关系

如图所示：

<img src="imgs\20200321203636254.png" alt="20200321203636254.png" />

他们都是java.util.concurrent包下面的类或接口

1. Executor接口

   这个接口提供了一种把任务的提交机制和任务的执行相分离的方式。里面有一个方法，

   ```java
   void execute(Runnable command);
   ```

   command表示提交的任务，具体如何执行，取决于实现。

2. ExecutorService接口

   ExecutorService继承了Executor接口，提供了比Executor更为通用的形式。

3. Executors类

   提供了一系列便捷地获取各种Executor实现类对象的工厂方法