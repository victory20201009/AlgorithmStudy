<center><font color="#FFA500" size="6">寻找峰值</font></center>

[TOC]

# 1 问题描述

峰值是一个数组中其值大于左右相邻的元素的值，例如数组arr=[1，2，3，2，1]，数字3就是峰值。现在要求编写代码，求出给定数组arr[0,n-1]的某一个峰值的下标，数组的数字都不相同，令arr[-1]=arr[n]=无穷小。

# 2 解题思路分析

## 2.1 最容易想到的办法，暴力破解

这个方法最容易，可以先判断两头。首先过滤掉数组长度小于等于1的情况。如果arr[0]>arr[1]，返回0；如果arr[n-1]>arr[n-2]，返回n-1；然后从arr[1]开始，到arr[n-2]，逐个判断每个元素的相邻元素和其大小关系；一旦发现满足条件的，就返回其下标。

## 2.2 二分加速

暴力的方法时间复杂度平均来说是$O(n)$。使用计算机解决的问题时，一个很重要的思想就是如何降低问题的规模；当面临一个复杂问题时，我们先不要想着如何直接解决它，要先看一下是否可以分解成相同类问题的，但规模小的问题的解。在本题中，峰值是，某一个值，左边递增，右边递减的；因此是`部分有序的`，这样的部分有序的数组，可以使用二分法来降低问题的规模。

借用二分查找的思想，思路描述如下：

首先取，0和n-1的一半mid，如果arr[mid]>arr[mid+1]，说明arr[mid]已经大于它的右边了。又因arr[-1]为无穷小，因此峰值必出现在mid左边(包括mid)，如果arr[mid]<=arr[mid+1]，说明arr[mid+1]已经大于等于其左边了，又由于arr[n]是无穷小，那么峰值一定在arr[mid]右边(不包括mid)。这样一来每一次就可以把问题的规模缩小一半，时间复杂度$O(\log_2n)$。

鉴于以上思路，代码编写如下：

```C
int find_peek(int *arr,int len){
    if(len<=1)return 0;
    int left = 0,right=len-1,mid;
    while(left<right){
        mid=((left+right)>>1);
        if(arr[mid]>arr[mid+1])right=mid;
        else left = mid+1;
    }
    return left;
}
```

