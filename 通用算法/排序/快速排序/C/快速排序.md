<center><font color="#FFA500" size="6">快速排序</font></center>

[TOC]

# 1 快速排序算法说明

这里讲解快速排序的实现方法，复杂度分析和优化。快速排序的思路是，选择一个基准点base，整理数组，使得基准点左边的数都小于等于base，基准点右边的数都大于等于base，然后返回这样的基准在数组中的索引。采用递归的方法，对左边的数组和右边的数组进行排序即可。实现这个过程函数，我们叫它partition，定义如下：

```C
int partition(int* arr,int start,int end);
```

那么快速排序可以这么写：

```C
void quick_sort(int* arr,int start,int end){
    if(arr!=NULL&&start<end){
        int base = partition(arr,start,end);
        if(start<base-1)quick_sort(arr,start,base-1);
        if(base<end-1)quick_sort(arr,base+1,end);
    }
}
```

partition有多种实现方式，可以选择数组中任何一个数作为基准，在这里使用随机基准的方式随机选择基准。我们产生[start,end]之间的随机数，方法如下：

```C
#include<stdlib.h>
#include<time.h>

int random_range(int start, int end) {
	srand((unsigned)time(NULL));
	return rand() % (end - start + 1) + start;
}
```

# 2 partition函数实现方法

## 2.1 第一种实现方法（甩锅法\^_\^）

![image-20200322234339285](md_img\image-20200322234339285.png)

把选择好的基准，和第一个元素交换，定义两个指针i，j，分别下指向start和end，先从end开始(这里不一定总是从end开始，当把基准和最后一个元素交换时，应该先从start开始)，当前元素大于等于基准时，--j，继续判断，否则交换i，j指向的元素，然后换另一头的指针i，当前元素小于等于基准时，++i，否则交换i，j指向的元素，然后换另一头的指针j，如此往复，直到i=j，返回i或j即可，当一头的指针发现当前元素不符合自己的条件时，就交换指针的内容，甩给另一头的指针，因此起名甩锅法。，如下图所示：

![image-20200323002305944](md_img\image-20200323002305944.png)

代码如下：

这里先写一个数组两个元素交换的方法，

```C
void swap(int* arr,int i,int j){
    if(i!=j&&arr[i]!=arr[j]){
        int t=arr[i];
        arr[i]=arr[j];
        arr[j] = t;
    }
}
```



```C
int partition_throw_pot(int* arr,int start,int end){
    int rand_index = random_range(start,end);
    swap(arr,start,rand_index);
    int base = arr[start],i=start,j=end;
    while(i<j){
        while(i<j&&arr[j]>=base)--j;
        if(i<j)swap(arr,i,j);
        while(i<j&&arr[i]<=base)++i;
        if(i<j)swap(arr,i,j);
    }
    return i;
}
```



## 2.2 第二种实现方法，哨兵法，第一种的改进，减少交换次数

第一种实现方法，每次每一头的指针发现不符合规则时，就进行交换，这样的交换，只是能满足另一方的需求(j发现一个小于基准的，就和i交换，但是i当前的不一定是大于等于基准的，不一定刚好满足j的需求)，可以等到i发现了一个大于基准的，j发现了一个小于基准的，再交换，就减少了交换次数。

```C
int partition_throw_pot(int* arr,int start,int end){
    int rand_index = random_range(start,end);
    swap(arr,start,rand_index);
    int base = arr[start],i=start,j=end;
    while(i<j){
        while(i<j&&arr[j]>=base)--j;
        while(i<j&&arr[i]<=base)++i;
        if(i<j)swap(arr,i,j);
    }
    swap(arr,start,i);
    return i;
}
```

注意，当最开始把基准移到数组最左端时，最后i、j相遇要把基准和i或j交换回来，因为最左端的元素一定时小于等于基准的，所以要保证i、j相遇时，指向的元素小于等于基准：只需要从j开始判断即可。原因：

- 能造成i=j的因素只有第6、第7行代码
- 当第6行代码使得i=j时，有两种情况：
  - 数组中的数都是大于等于基准的，这样第7、第8行代码判断不通过，循环结束，i指向基准
  - 数组中的数不都是大于等于基准的，这样在某一次判断中，使得i=j，这时，在此之前，第8行代码执行了一次，i所在的数一定小于等于基准
- 当第7行代码使得i=j时，有两种情况：
  - 数组中的数都是小于等于基准的，这样第6、第8行代码判断不通过，循环结束，i指向end
  - 数组中的数不都是小于等于基准的，这样在某一次判断中，使得i=j，这时，在此之前，第6行代码执行了一次，j所在的数一定小于等于基准

## 2.3 第三种实现方法，第二种的改进

每次都交换，不如直接覆盖来的快，可以先把基准保存在一个变量里，当j当前元素不满足条件时，就把j当前元素，覆盖到i当前元素，当i第一次被覆盖时，覆盖的是基准，随后i或j，至少有一个指向的元素是现有数组中某个元素的拷贝，当i=j时，把基准覆盖到i或j即可，代码如下：

```C
int partition_throw_pot(int* arr,int start,int end){
    int rand_index = random_range(start,end);
    swap(arr,start,rand_index);
    int base = arr[start],i=start,j=end;
    while(i<j){
        while(i<j&&arr[j]>=base)--j;
        if(i<j)arr[i++]=arr[j];
        while(i<j&&arr[i]<=base)++i;
        if(i<j)arr[j--]=arr[i];
    }
    //基准覆盖回来
    arr[i]=base;
    return i;
}
```

## 2.4 第四种实现方法，区间法

![image-20200323015756536](md_img\image-20200323015756536.png)

![image-20200323020221019](md_img\image-20200323020221019.png)

