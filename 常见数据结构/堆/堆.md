<center><font color="#FFA500" size="6">堆</font></center>

[TOC]

# 1.堆的存储

堆是使用数组存储的完全二叉树。然后按照从上到下，从左到右的依次存储在数组中，堆就是这样存储的。

> 完全二叉树：一棵深度为k的有n个结点的[二叉树](https://baike.baidu.com/item/二叉树/1602879)，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树 [百度百科]
>
> 满二叉树：一棵深度为k且有$2^{k}-1$个结点的二叉树称为满二叉树 [百度百科]

# 2. 堆存储的性质

【结论1】：设堆的结点个数为N，数组索引范围[0，N-1]，对于任意一个结点，其索引$i$，其父节点(如果有的话)$p$，左孩子(如果有的话)$l$，右孩子(如果有的话)$r$，

且$i,p,l,r\in[0,N-1]$那么下面的公式成立：
$$
p=\lfloor\frac{i-1}{2}\rfloor\\
l = 2i+1\\
r = l+1
$$
简单的证明一下：只需要证明$l = 2i+1$即可。对于满二叉树，它每一层的节点数是$L(h) = 2^{h-1},h\in[1,+\infty)$，每层节点数成等比数列，前N层的节点数之和：$S(N) = \sum_{i=1}^{N}{2^{i-1}} = 2^{N}-1（运用等比数列求和）$，可以得到$S(N)$只是比第N+1层的节点数$2^{N+1-1}=2^{N}$少了1，所以$S(N) = L(N+1)-1$，也就是说，某一层的节点数等于前面所有层的节点数+1。如果索引从0开始编号，每个元素的索引表示它前面的所有元素的个数。我们只需要知道在编号为$i$的结点的左孩子前面，还有几个元素即可：

设索引为$i$的结点所在的层编号是$h$，这一层第一个结点的索引为$k$，且令$offset = i-k$，表示在第h层，在i之前还有offset个结点。那么前h层，一共有$k+k+1=2k+1$个结点，l一定在h+1层，那个它距离h+1层第一个结点的偏移是$2offset = 2i-2k$，那么在l之前一共有$2k+1+2i-2k=2i+1$个结点，

即l的索引是$2i+1$。

【结论2】：层数为h的满二叉树的结点总数为$2^{h}-1$，如果一个堆的结点个数为N，那么它的层数$L = \lceil\log_{2}{(N+1)}\rceil$，高度$H = L-1$

【结论3】：设堆的元素个数为N，最后一个具有子结点的索引是k，如果：

- N是偶数，则N-1是奇数，由于右孩子的索引是$2i+2$是偶数，所以最后一个具有子结点的结点，没有右孩子，只有左孩子，那么其左子结点索引$2k+1$，则$2k+1<N=>k<=\lfloor\frac{N-1}{2}\rfloor$，剩下的都是叶子结点，叶子节点的索引范围$[\lfloor\frac{N-1}{2}\rfloor+1,N-1]$，由于N是偶数，$\lfloor\frac{N-1}{2}\rfloor+1 = \frac{N}{2}$，即叶子节点的索引范围$[\frac{N}{2},N-1]$。
- N是奇数，则N-1是偶数，则最后一个具有子结点的结点有右孩子，即$2k+2<N=>k<\frac{N-2}{2}=>k<=\lfloor\frac{N}{2}\rfloor-1$，即叶子节点的索引范围$[\lfloor\frac{N}{2}\rfloor,N-1]$.

当N是整数时，$\lfloor\frac{N}{2}\rfloor=\frac{N}{2}$，综上，叶子结点的范围$[\frac{N}{2},N-1]$；可以看出几乎一半都是叶子结点。

# 3 最大堆/最小堆

定义很简单：最大堆就是对于任何一个结点，他的值都要小于其父结点，位于堆顶的元素是最大的；相应的，最小堆就是对于任何一个结点，他的值都要大于其父结点。

设array是存储堆元素的数组，i是任何一个结点的索引，其父节点索引$p(i)$，对于最大堆有：$array[i]<array[p(i)]$成立，显然一个排序的数组就是一个最大堆/最小堆，反之不真。

# 4 堆的操作

1. 上浮
2. 下沉
3. 插入
4. 删除
5. 返回堆顶

其中前两个是基本操作，保证了堆的顺序

## 4.1 返回堆顶

堆顶就是对数组中第一个元素，这个最简单，时间复杂度$O(1)$

## 4.2 上浮/下沉

当一个元素不满足堆顺序的时候，例如在小顶堆里，一个元素比其父元素还要小，我们可以把它和其父元素交换位置进行"冒泡"，把小的值往上浮以调整；同理在小顶堆里，一个元素比其子元素还要大，我们可以把它和其子元素交换位置进行"下沉"，二者是相对而言的。

## 4.3 插入操作

我们可以先把需要插入的元素放在堆的末尾，比较新元素和其父元素的大小，不满足堆顺序的时候，就和其父结点交换，即上浮来调整堆，直到堆的根结点为止。

可以发现，从某个叶子结点(堆的末尾的肯定是叶子)，不断寻找其父结点，直到根结点，构成了从根节点到叶子结点的一条路径，这个路径的长度，不超过堆的高度，堆高度的计算，见上面的【结论2】，所以上浮执行次数是$\log_2{N}$级别，即插入操作时间复杂度$O(\log_2N)$。

## 4.4 删除操作

首先看一下删除堆顶，做法就是把堆顶元素和最后一个交换，然后返回最后一个元素，把堆的边界-1，然后把新的堆顶下沉即可。

下沉的时候注意，如果是小顶堆，父结点需要和最小的那一个子结点交换位置即可，直到遇到叶子结点，同理时间复杂度$O(\log_2N)$。

删除任意的元素以后再说。

## 4.5 把数组调整成堆

我们可以把所有的元素都依次做下沉操作来调整堆，这样就得到一个有效的堆了。因为叶子结点没有子结点，所以不需要下沉，即只需要从第一个非叶子结点开始，向前扫描，依次执行下沉操作。

代码如下：

```C++
#include<iostream>
#include<vector>
using namespace std;
 
void adjustHeap(vector<int> &myheap, int k){
    int len = myheap.size();
    /**
    *  叶子结点不需要调整
    */
    while(k <= len/2-1){
       /**
    	*  (当k <= len/2-1，左孩子一定存在，右孩子不一定)
    	*  当前结点比左孩子大，当右孩子存在时，也比右孩子大，不需要调整
    	*/
        if(myheap[k]>myheap[2*k+1] && ((2*(k+1)>=len)||myheap[k]>myheap[2*(k+1)]))
            break;
        
       /**
    	*  当前结点比左孩子小，当右孩子存在时，左孩子比右孩子大，只需要让当前结点跟较大的交换即可
    	*/
        if(myheap[k] <= myheap[2*k+1] && ((2*(k+1)>=len)||myheap[2*k+1] >= myheap[2*(k+1)])){
            swap(myheap[k], myheap[2*k+1]);
            k = 2*k+1; 
        }
        
       /**
    	*  当前结点比左孩子小，当右孩子存在且左孩子比右孩子小，只需要让当前结点跟右孩子的交换即可
    	*/
        if(myheap[k] <= myheap[2*k+1] && (2*(k+1)<len)&&myheap[2*k+1] < myheap[2*(k+1)]){
            swap(myheap[k], myheap[2*(k+1)]);
            k = 2*(k+1);
        }
    }
}
 
/**
* 构建最大堆
*/
void buildHeap(vector<int> &myheap)
{
    if(myheap.size() <= 1) return;
    /**
    * 从上面的结论【结论3】中得知，第一个叶子结点索引N/2，则最后一个非叶子结点的索引N/2-1
    */
    for(int i = myheap.size()/2-1; i >= 0; i--)
        adjustHeap(myheap, i);
}
 
int main()
{
    vector<int> myheap{4, 1, 3, 4, 5, 7, 2, 6, 8, 0};
    buildHeap(myheap);
    for(int i = 0; i < (int)myheap.size(); i++)
        cout << myheap[i] << endl;
}
```

时间复杂度分析：

设堆层数为$K\in\{x|x>=1,x\in{N}\}$，第i层的结点个数$2^{i-1}，i\in[1,K-1]$(最后一层是叶子)，第i层下沉所需要的交换次数，不超过当前层的高度$K-i$，那么所有的交换次数$S(K) = \sum_{i=1}^{K-1}{(K-i)2^{i-1}}$，等差比数列求和，求得$S(K) = 2^k-k-1$，设堆的结点个数$N$，根据【结论2】，有$K = \lceil\log_2{(N+1)}\rceil$，代入$S(K)$，得到$S(N) = O(N)-\lceil\log_2{(N+1)}\rceil=O(N)$。

# 5 堆的应用

## 5.1 求topK

例如求一个数组中最大的K个数，只需要把数组的前K个数建立最小堆，遍历剩下的元素，当当前元素比堆顶大时，替换堆顶，调整堆。这样，当遍历完毕的时候，堆顶元素就是整个数组第K大的元素，自然堆中的所有元素即为topK。

时间复杂度：设当前数组元素个数N，调整堆的时间$O(\log_2K)$，调整的次数$N-K$，所以时间复杂度$(N-K)\log_2K$。

## 5.2 排序

例如要对于一个数组升序排序，可以先把数组转化为大顶堆，设置一个指针last指向数组末尾元素，对于从索引为N-1到1的每一个元素，做以下动作：

- 把array[last]与array[0]交换；
- 调整剩下的元素组成的堆；
- last--；

直到last==0，结束(最后一个不用排序)。

时间复杂度：设当前数组元素个数N，每次调整堆时间$O(\log_2N)$，调整次数：$N-1$，即时间复杂度：$(N-1)\log_2N$

# 6 参考资料

[数据结构(堆-简书)](https://www.jianshu.com/p/6b526aa481b1)

[数组建堆(heapify)](https://blog.csdn.net/qq508618087/article/details/53362999)